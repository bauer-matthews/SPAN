# NAME: DC-net Protocol
# PARAMETERS: 2 parties

.metadata

    version : 1.0;
    recipe depth : 1;

.constants

.signature

    sort : Key, Bit, Nonce, Message;
    subsort : Key, Nonce, Bit < Message;

    variables : mes, m1, m2, y1, y2, y3, y4 | Message;
    variables : r | Nonce;
    variables : key | Key;
    variables : bit, x, y, z, b, b1, b2 | Bit;

    function : senc | Message Key -> Message;
    function : sdec | Message Key -> Message;
    function : pair | Message Message -> Message;
    function : fst | Message -> Message;
    function : snd | Message -> Message;
    function : xor | Bit Bit -> Bit;
    function : zero | -> Bit;
    function : one | -> Bit;
    function : val | Bit Bit Bit Bit Nonce -> Message;

    public names : g | Bit;

    private names : s | Nonce;
    private names : k | Key;
    private names : r1, r2, r3, r4 | Nonce;

.rewrites

    rewrite : sdec(senc(mes,key), key) -> mes;
    rewrite : fst(pair(m1, m2)) -> m1;
    rewrite : snd(pair(m1, m2)) -> m2;
    rewrite : xor(one, one) -> zero;
    rewrite : xor(one, zero) -> one;
    rewrite : xor(zero, one) -> one;
    rewrite : xor(zero, zero) -> zero;
    rewrite : val(bit, zero, b1, b2, r) -> pair(xor(bit, b1), b2);
    rewrite : val(bit, one, b1, b2, r) -> pair(b1, xor(bit,b2));

.roles

    role :          {0} [T] out(1/8 -> senc(pair(pair(zero, zero), zero), k) # A  +
                                1/8 -> senc(pair(pair(zero, zero), one), k) # B +
                                1/8 -> senc(pair(pair(zero, one), zero), k) # A +
                                1/8 -> senc(pair(pair(zero, one), one), k) # B +
                                1/8 -> senc(pair(pair(one, one), one), k) # B +
                                1/8 -> senc(pair(pair(one, one), zero), k) # A +
                                1/8 -> senc(pair(pair(one, zero), one), k) # B +
                                1/8 -> senc(pair(pair(one, zero), zero), k) # A);

    role :          {1} in(y1{senc(pair(pair(x, y), z), k)}) .
                    {1} [T] out(1/2 -> val(zero, snd(sdec(y1, k)), fst(fst(sdec(y1, k))), snd(fst(sdec(y1, k))), r1) +
                                1/2 -> val(one, snd(sdec(y1, k)), fst(fst(sdec(y1, k))), snd(fst(sdec(y1, k))), r2));

    role :          {1} in(y2{senc(pair(pair(x, y), z), k)}) .
                    {1} [T] out(1/2 -> val(zero, xor(snd(sdec(y2, k)), one), fst(fst(sdec(y2, k))), snd(fst(sdec(y2, k))), r3) +
                                1/2 -> val(one, xor(snd(sdec(y2, k)), one), fst(fst(sdec(y2, k))), snd(fst(sdec(y2, k))), r4) );

    subrole(A)  :   {2} in(y4{b}) .
                    {2} [y4 == zero ] out(1 -> s);

    subrole(B)  :   {2} in(y4{b}) .
                    {2} [y4 == one ] out(1 -> s);

.safety
    secrecy : s >= 1/2;