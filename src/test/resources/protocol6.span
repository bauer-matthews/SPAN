# Example Protocol

.metadata

    version : 1.0;
    recipe depth : 2;

.constants

    fraction p : 1/2;

.signature

    // Need to parse sorts first / Check other orders
    // T, W are reserved strings for names/functions/types/variables;

    sort : Key, Nonce, Message;
    subsort : Key Nonce < Message;

    variables : m, y1, y2, y3, x1 | Message;
    variables : r, x2 | Nonce;
    variables : k | Key;

    function : enc | Message Nonce Key -> Message;
    function : dec | Message Key -> Message;
    function : pk | Key -> Key;
    function : sk | key -> key;

    public names : a | Message;

    private names : m1 , m2 | Message;
    private names : k1, k2, km | Key;
    private names : s, r1, r2, r3, r4 | Nonce;

.rewrites

    rewrite : dec(enc(m,r,pk(k)), sk(k)) -> m;

.roles

    role : [T] out(1 -> enc(enc(m1,r1, pk(k1)),r2, pk(km))) . [T] out(1 -> enc(enc(m2,r3, pk(k2)),r4, pk(km))) .
             in(y1{enc(x1,x2, pk(km))}) . in(y2{enc(x1, x2, pk(km))}) .
             [y1 != y2] out(p -> dec(y1, sk(km)) # dec(y2, sk(km)) + p -> dec(y2, sk(km)) # dec(y1, sk(km))) .
             in(y3{enc(m2,r3, pk(k2))}) . [ y3 == enc(m2,r3, pk(k2))  ] out(1 -> s)

.safety
    secrecy : s >= 1/2;