# Example Protocol
# note b0 = 0
# note b1 = 1
# mA = 0
# mB = 1
# I can allow b0 and b1 to vary with more coin flips in phase 0

.metadata

    version : 1.0;
    recipe depth : 2;

.constants

    fraction p : 1/2;

.signature

    sort : Key, Bit, Nonce, Message;
    subsort : Key, Nonce, Bit < Message;

    variables : mes, m1, m2, y1, y2 | Message;
    variables : r | Nonce;
    variables : key | Key;
    variables : bit, x, y, z, b, b1, b2 | Bit;

    function : senc | Message Key -> Message;
    function : sdec | Message Key -> Message;
    function : pair | Message Message -> Message;
    function : fst | Message -> Message;
    function : snd | Message -> Message;
    function : xor | Bit Bit -> Bit;
    function : zero | -> Bit;
    function : one | -> Bit;
    function : val | Bit Bit Bit Bit -> Message;

    public names : g | Bit;

    private names : s | Nonce;
    private names : k | Key;

.rewrites

    rewrite : sdec(senc(mes,key), key) -> mes;
    rewrite : fst(pair(m1, m2)) -> m1;
    rewrite : snd(pair(m1, m2)) -> m2;
    rewrite : xor(one, one) -> zero;
    rewrite : xor(one, zero) -> one;
    rewrite : xor(zero, one) -> one;
    rewrite : xor(zero, zero) -> zero;
    rewrite : val(bit, zero, b1, b2) -> pair(xor(bit, b1), b2);
    rewrite : val(bit, one, b1, b2) -> pair(b1, xor(bit,b2));

.roles

    role :  {0} [T] out(1/8 -> senc(pair(pair(zero, zero), zero), k) +
                        1/8 -> senc(pair(pair(zero, zero), one), k) +
                        1/8 -> senc(pair(pair(zero, one), zero), k) +
                        1/8 -> senc(pair(pair(zero, one), one), k) +
                        1/8 -> senc(pair(pair(one, one), one), k) +
                        1/8 -> senc(pair(pair(one, one), zero), k) +
                        1/8 -> senc(pair(pair(one, zero), one), k) +
                        1/8 -> senc(pair(pair(one, zero), zero), k));

    role :  {1} in(y1{senc(pair(pair(x, y), z), k)}) .
            {1} [T] out(1/2 -> val(zero, snd(sdec(y1, k)), zero, one) +
                        1/2 -> val(one, snd(sdec(y1, k)), zero, one));

    role :  {1} in(y1{senc(pair(pair(x, y), z), k)}) .
            {1} [T] out(1/2 -> val(zero, xor(snd(sdec(y1, k)), one), zero, one) +
                        1/2 -> val(one, xor(snd(sdec(y1, k)), one), zero, one) );

    role :  {2} in(y1{senc(pair(pair(x, y), z), k)}) .
            {2} in(y2{b}) .
            {2} [snd(sdec(y1, k)) == y2 ] out(1 -> s);

.safety
    secrecy : s >= 1/2;